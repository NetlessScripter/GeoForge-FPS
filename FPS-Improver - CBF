loadstring(game:HttpGet("https://raw.githubusercontent.com/NetlessScripter/Jukebox/refs/heads/main/Jukebox"))()
loadstring(game:HttpGet("https://raw.githubusercontent.com/NetlessScripter/GeoForge-FPS/refs/heads/main/Audio%20Quick%20Loader"))()

local Services = setmetatable({}, {
    __index = function(t, k)
        local s = game:GetService(k)
        rawset(t, k, s)
        return s
    end
})

local Players = Services.Players
local RS = Services.RunService
local CP = Services.ContentProvider
local RepStorage = Services.ReplicatedStorage
local WS = Services.Workspace
local UIS = Services.UserInputService
local Stats = Services.Stats
local Lighting = Services.Lighting
local CS = Services.CollectionService
local HttpService = Services.HttpService
local ContextActionService = Services.ContextActionService

local lp = Players.LocalPlayer
local mouse = lp:GetMouse()

local CFG = {
    RENDER_DIST = {
        ULTRA = 2500,
        HIGH = 1800,
        MEDIUM = 1200,
        LOW = 800,
        POTATO = 500
    },
    LOD_LEVELS = 4,
    UPDATE_INTERVAL = 0.15,
}

local isMobile = UIS.TouchEnabled and not UIS.KeyboardEnabled
local currentRenderDist = isMobile and CFG.RENDER_DIST.MEDIUM or CFG.RENDER_DIST.HIGH

local objectCache = {}
local cacheCount = 0

local function createCache(model)
    if objectCache[model] then return end
    
    local cache = {
        parts = {},
        originalTransparencies = {},
        particles = {},
        lights = {},
        effects = {},
        primaryPart = nil,
        lodLevel = 1,
    }
    
    local success, prim = pcall(function()
        return model.PrimaryPart or model:FindFirstChildWhichIsA("BasePart", true)
    end)
    
    if not success or not prim then return end
    cache.primaryPart = prim
    
    for _, v in ipairs(model:GetDescendants()) do
        if v:IsA("BasePart") then
            table.insert(cache.parts, v)
            table.insert(cache.originalTransparencies, v.Transparency)
        elseif v:IsA("ParticleEmitter") then
            table.insert(cache.particles, v)
        elseif v.ClassName:match("Light$") then
            table.insert(cache.lights, v)
        elseif v:IsA("Beam") or v:IsA("Trail") then
            table.insert(cache.effects, v)
        end
    end
    
    objectCache[model] = cache
    cacheCount = cacheCount + 1
end

local function destroyCache(model)
    if objectCache[model] then
        objectCache[model] = nil
        cacheCount = math.max(0, cacheCount - 1)
    end
end

local function applyLOD(cache, distance)
    if not cache or not cache.primaryPart or not cache.primaryPart.Parent then return end
    
    local newLOD = 1
    if distance > currentRenderDist then
        newLOD = 4
    elseif distance > currentRenderDist * 0.7 then
        newLOD = 3
    elseif distance > currentRenderDist * 0.4 then
        newLOD = 2
    end
    
    if newLOD == cache.lodLevel then return end
    cache.lodLevel = newLOD
    
    if newLOD == 4 then
        for i, part in ipairs(cache.parts) do
            part.Transparency = 1
            part.CastShadow = false
        end
        for _, p in ipairs(cache.particles) do p.Enabled = false end
        for _, l in ipairs(cache.lights) do l.Enabled = false end
        for _, e in ipairs(cache.effects) do e.Enabled = false end
    elseif newLOD == 3 or newLOD == 2 then
        for i, part in ipairs(cache.parts) do
            part.Transparency = cache.originalTransparencies[i]
            part.CastShadow = false
        end
        for _, p in ipairs(cache.particles) do p.Enabled = false end
        for _, l in ipairs(cache.lights) do l.Enabled = false end
        for _, e in ipairs(cache.effects) do e.Enabled = false end
    else
        for i, part in ipairs(cache.parts) do
            part.Transparency = cache.originalTransparencies[i]
            part.CastShadow = not isMobile
        end
        for _, p in ipairs(cache.particles) do p.Enabled = true end
        for _, l in ipairs(cache.lights) do l.Enabled = true end
        for _, e in ipairs(cache.effects) do e.Enabled = true end
    end
end

local PerfMonitor = {
    enabled = true,
    currentFPS = 60,
    lastUpdate = 0,
}

function PerfMonitor:UpdateLODs()
    if not self.enabled then return end
    
    local now = os.clock()
    if now - self.lastUpdate < CFG.UPDATE_INTERVAL then return end
    self.lastUpdate = now
    
    local camera = WS.CurrentCamera
    if not camera then return end
    
    local camPos = camera.CFrame.Position
    
    for model, cache in pairs(objectCache) do
        if model and model.Parent and cache.primaryPart and cache.primaryPart.Parent then
            local distance = (cache.primaryPart.Position - camPos).Magnitude
            applyLOD(cache, distance)
        else
            destroyCache(model)
        end
    end
    
    self.currentFPS = 1 / math.max(0.001, RS.Heartbeat:Wait())
    
    if self.currentFPS < 40 then
        currentRenderDist = math.max(CFG.RENDER_DIST.POTATO, currentRenderDist * 0.9)
        Lighting.GlobalShadows = false
    elseif self.currentFPS > 100 and currentRenderDist < CFG.RENDER_DIST.HIGH then
        currentRenderDist = math.min(CFG.RENDER_DIST.HIGH, currentRenderDist * 1.05)
    end
end

CS:GetInstanceAddedSignal("PerfCull"):Connect(createCache)
CS:GetInstanceRemovedSignal("PerfCull"):Connect(destroyCache)
for _, obj in ipairs(CS:GetTagged("PerfCull")) do createCache(obj) end

task.spawn(function()
    while true do
        PerfMonitor:UpdateLODs()
        RS.Heartbeat:Wait()
    end
end)

local PreloadQueue = {pending = {}, loading = {}, loaded = {}}

local function preloadAsync(assets, priority)
    for i = 1, #assets do
        local asset = assets[i]
        if not PreloadQueue.loaded[asset] and not PreloadQueue.loading[asset] then
            table.insert(PreloadQueue.pending, {asset = asset, priority = priority or 1})
        end
    end
end

task.spawn(function()
    while true do
        if #PreloadQueue.pending > 0 then
            table.sort(PreloadQueue.pending, function(a, b) return a.priority > b.priority end)
            
            local batch = {}
            for i = 1, math.min(50, #PreloadQueue.pending) do
                local item = table.remove(PreloadQueue.pending, 1)
                table.insert(batch, item.asset)
                PreloadQueue.loading[item.asset] = true
            end
            
            if #batch > 0 then
                pcall(function()
                    CP:PreloadAsync(batch, function(assetId, status)
                        PreloadQueue.loading[assetId] = nil
                        if status == Enum.AssetFetchStatus.Success then
                            PreloadQueue.loaded[assetId] = true
                        end
                    end)
                end)
            end
        end
        task.wait(0.1)
    end
end)

local soundIds = {
    "rbxassetid://108307407632074", "rbxassetid://18702401696", "rbxassetid://96127020943905",
    "rbxassetid://137767105602020", "rbxassetid://129776444939548", "rbxassetid://18702400636",
    "rbxassetid://102731560381318", "rbxassetid://138845097957088", "rbxassetid://79469974423674",
    "rbxassetid://131606709385617", "rbxassetid://85287961214592", "rbxassetid://119216849744019",
    "rbxassetid://118356803581572", "rbxassetid://82795066015990", "rbxassetid://134237590026353"
}

local soundAssets = {}
for _, id in ipairs(soundIds) do
    local s = Instance.new("Sound")
    s.SoundId = id
    s.Volume = 0
    table.insert(soundAssets, s)
end
preloadAsync(soundAssets, 10)

pcall(function()
    local gameAssets = {}
    for _, folder in ipairs({
        RepStorage.GameObjects.Decoration,
        RepStorage.GameObjects.Hazards,
        RepStorage.GameObjects.Particles,
        RepStorage.GameObjects.Specials
    }) do
        for _, obj in ipairs(folder:GetDescendants()) do
            table.insert(gameAssets, obj)
        end
    end
    preloadAsync(gameAssets, 5)
end)

task.spawn(function()
    pcall(function()
        local uiM = require(lp.PlayerScripts.Client.UI.UIManager)
        local ui = uiM.new(lp.PlayerGui.MainUI)
        local customMenu = lp.PlayerGui:WaitForChild("MainUI"):WaitForChild("States"):WaitForChild("CustomizationMenu")
        
        local preloadAssets = {}
        for _, obj in ipairs(customMenu:GetDescendants()) do
            if obj:IsA("ImageLabel") or obj:IsA("ImageButton") or obj:IsA("Sound") or
               obj:IsA("Decal") or obj:IsA("Texture") or obj:IsA("ParticleEmitter") then
                table.insert(preloadAssets, obj)
            end
        end
        preloadAsync(preloadAssets, 8)
        
        customMenu.DescendantAdded:Connect(function(obj)
            if obj:IsA("ImageLabel") or obj:IsA("ImageButton") or obj:IsA("Sound") then
                preloadAsync({obj}, 8)
            end
        end)
    end)
end)

local NongSystem = {cache = {}, mirrors = {}}

local function safeIsfile(name)
    local ok, result = pcall(function() return isfile(name) end)
    return ok and result or false
end

local function safeWritefile(name, data)
    return pcall(function() writefile(name, data) end)
end

local function safeHttpGet(url)
    local ok, result = pcall(function() return game:HttpGet(url) end)
    return ok and result or nil
end

local function getAssetPath(name)
    if typeof(getsynasset) == "function" then return getsynasset(name)
    elseif typeof(getcustomasset) == "function" then return getcustomasset(name) end
    return nil
end

function NongSystem:DownloadAsync(url, filename)
    if safeIsfile(filename) then return true end
    task.spawn(function()
        local body = safeHttpGet(url)
        if body then
            safeWritefile(filename, body)
            self.cache[filename] = true
        end
    end)
end

function NongSystem:CreateMirror(originalId, url)
    local filename = url:match("^.+/(.+)$") or ("sound_" .. tostring(math.random(100000, 999999)))
    self:DownloadAsync(url, filename)
    local assetPath = getAssetPath(filename)
    
    local function makeMirror(src)
        if not src or src:FindFirstChild("MirrorAttached") then return end
        src.Volume = 0
        
        local mirror = Instance.new("Sound")
        mirror.Name = filename
        mirror.SoundId = assetPath or originalId
        mirror.Volume = 1
        mirror.Looped = src.Looped
        mirror.PlaybackSpeed = src.PlaybackSpeed
        mirror.Parent = WS
        
        local tag = Instance.new("BoolValue")
        tag.Name = "MirrorAttached"
        tag.Parent = src
        
        local dead = false
        local function sync()
            if dead or not src.Parent then
                dead = true
                if mirror and mirror.Parent then mirror:Destroy() end
                if tag and tag.Parent then tag:Destroy() end
                return
            end
            pcall(function()
                mirror.Looped = src.Looped
                mirror.PlaybackSpeed = src.PlaybackSpeed
                mirror.TimePosition = src.TimePosition
            end)
            if src.Playing and not mirror.Playing then
                pcall(function() mirror:Play() end)
            elseif not src.Playing and mirror.Playing then
                pcall(function() mirror:Pause() end)
            end
        end
        
        src:GetPropertyChangedSignal("Playing"):Connect(sync)
        src:GetPropertyChangedSignal("TimePosition"):Connect(function()
            if not dead then pcall(function() mirror.TimePosition = src.TimePosition end) end
        end)
        src.AncestryChanged:Connect(function(_, parent)
            if not parent then
                dead = true
                pcall(function() mirror:Destroy() end)
                pcall(function() tag:Destroy() end)
            end
        end)
        sync()
    end
    
    local function watchContainer(container)
        for _, v in ipairs(container:GetDescendants()) do
            if v:IsA("Sound") and v.SoundId == originalId then makeMirror(v) end
        end
        container.DescendantAdded:Connect(function(v)
            if v:IsA("Sound") and v.SoundId == originalId then makeMirror(v) end
        end)
    end
    
    watchContainer(WS)
    watchContainer(RepStorage)
    watchContainer(Services.SoundService)
end

NongSystem:CreateMirror(
    "rbxassetid://97722189026920",
    "https://raw.githubusercontent.com/NetlessScripter/GeoForge/refs/heads/main/menuLoop.mp3"
)

local CBF = {
    timeOrigin = os.clock(),
    tickOrigin = tick(),
    
    pollingRates = {
        primary = 1000,
        secondary = 500,
        tertiary = 240,
    },
    
    TPS = 480,
    maxTPS = 1000,
    currentTPS = 480,
    stepDelta = 1/480,
    subStepsPerStep = 4,
    
    inputQueues = {
        instant = {},
        primary = {},
        quantum = {},
        predictive = {},
        echo = {},
    },
    
    queueSizes = {
        instant = 0,
        primary = 0,
        quantum = 0,
        predictive = 0,
        echo = 0,
    },
    
    maxQueueSize = 2048,
    
    physicsStepInjection = {
        enabled = true,
        injectedSteps = {},
        stepCount = 0,
        maxInjections = 1000,
    },
    
    inputStates = {
        mouse1 = {
            current = false,
            previous = false,
            pressTime = 0,
            releaseTime = 0,
            holdDuration = 0,
            velocity = 0,
            acceleration = 0,
            quantumStates = {},
        }
    },
    
    history = {
        inputs = {},
        size = 0,
        maxSize = 1000,
        patterns = {},
        intervals = {},
    },
    
    predictor = {
        enabled = true,
        confidence = 0,
        patterns = {},
        intervals = {},
        averageInterval = 0,
        nextPredicted = 0,
        learningRate = 0.2,
        accuracy = 0,
        predictions = {},
    },
    
    interpolator = {
        enabled = true,
        method = "hermite",
        points = {},
        maxPoints = 1000,
    },
    
    extrapolator = {
        enabled = true,
        lookahead = 0.0001,
        predictions = {},
    },
    
    chaos = {
        enabled = false,
        intensity = 0,
        jitter = 0,
        boost = 1.0,
        quantumFluctuation = false,
        temporalNoise = false,
    },
    
    echo = {
        enabled = true,
        count = 3,
        spacing = 0.05,
        decay = 0.9,
    },
    
    temporal = {
        enabled = false,
        shifts = {},
    },
    
    frameSync = {
        enabled = true,
        frameNumber = 0,
        subFrame = 0,
        microFrame = 0,
        nanoFrame = 0,
        picoFrame = 0,
        lastFrameTime = 0,
    },
    
    stats = {
        totalInputs = 0,
        processedInputs = 0,
        injectedSteps = 0,
        droppedInputs = 0,
        
        avgLatency = 0,
        minLatency = math.huge,
        maxLatency = 0,
        
        perfectInputs = 0,
        subMicrosecondInputs = 0,
        instantInputs = 0,
        
        totalProcessingTime = 0,
        avgProcessingTime = 0,
        peakProcessingTime = 0,
        
        queueStats = {},
    },
    
    callbacks = {
        onInput = nil,
        onPhysicsStep = nil,
        onFrameSync = nil,
    },
    
    enabled = true,
    instantMode = true,
    physicsInjection = true,
    zeroLatency = true,
}

local function getPicoTime()
    local base = (os.clock() - CBF.timeOrigin) * 1e12
    local tick_component = (tick() - CBF.tickOrigin) * 1e12
    local hardware_offset = (os.clock() % 0.000001) * 1e12
    return base + (tick_component * 0.05) + hardware_offset
end

local function getNanoTime()
    return getPicoTime() / 1000
end

local function getMicroTime()
    return getNanoTime() / 1000
end

local function getMilliTime()
    return getMicroTime() / 1000
end

local function injectPhysicsStep(timestamp, inputType)
    if not CBF.physicsStepInjection.enabled then return end
    if CBF.physicsStepInjection.stepCount >= CBF.physicsStepInjection.maxInjections then return end
    
    local step = {
        timestamp = timestamp,
        inputType = inputType,
        injectedAt = getMicroTime(),
        processed = false,
    }
    
    table.insert(CBF.physicsStepInjection.injectedSteps, step)
    CBF.physicsStepInjection.stepCount = CBF.physicsStepInjection.stepCount + 1
    CBF.stats.injectedSteps = CBF.stats.injectedSteps + 1
    
    if CBF.callbacks.onPhysicsStep then
        pcall(function()
            CBF.callbacks.onPhysicsStep(step)
        end)
    end
end

local function queueToMultipleQueues(inputType, timestamp, priority)
    local queues = {
        {name = "instant", priority = 1000},
        {name = "primary", priority = 100},
    }
    
    local relativeTime = (os.clock() - (CBF.frameSync.lastFrameTime or os.clock()))
    
    for _, queueData in ipairs(queues) do
        local queueName = queueData.name
        local queue = CBF.inputQueues[queueName]
        
        if CBF.queueSizes[queueName] < CBF.maxQueueSize then
            local input = {
                type = inputType,
                timestamp = timestamp,
                relativeTime = relativeTime,
                priority = priority + queueData.priority,
                processed = false,
                queueName = queueName,
                frameNumber = CBF.frameSync.frameNumber,
                subFrame = CBF.frameSync.subFrame,
            }
            
            table.insert(queue, input)
            CBF.queueSizes[queueName] = CBF.queueSizes[queueName] + 1
        end
    end
end

local function queueQuantumInput(inputType, timestamp)
    if CBF.queueSizes.quantum >= CBF.maxQueueSize then return end
    
    local states = {}
    for i = 1, 5 do
        states[i] = math.random() > 0.3
    end
    
    local input = {
        type = inputType,
        timestamp = timestamp,
        quantumStates = states,
        waveFunction = math.random(),
        collapsed = false,
        relativeTime = (os.clock() - (CBF.frameSync.lastFrameTime or os.clock())),
        processed = false,
    }
    
    table.insert(CBF.inputQueues.quantum, input)
    CBF.queueSizes.quantum = CBF.queueSizes.quantum + 1
end

local function queueEchoInputs(baseInput)
    for i = 1, CBF.echo.count do
        if CBF.queueSizes.echo >= CBF.maxQueueSize then break end
        
        local timeOffset = i * CBF.echo.spacing
        local amplitude = CBF.echo.decay ^ i
        
        local echo = {
            type = baseInput.type .. "_echo",
            timestamp = baseInput.timestamp + timeOffset,
            echoIndex = i,
            amplitude = amplitude,
            originalTimestamp = baseInput.timestamp,
            relativeTime = baseInput.relativeTime,
            processed = false,
        }
        
        table.insert(CBF.inputQueues.echo, echo)
        CBF.queueSizes.echo = CBF.queueSizes.echo + 1
    end
end

local function queueTemporalInputs(baseInput)
    for _, shift in ipairs(CBF.temporal.shifts) do
        if CBF.queueSizes.temporal >= CBF.maxQueueSize then break end
        
        local temporal = {
            type = baseInput.type .. "_temporal",
            timestamp = baseInput.timestamp + shift,
            timeShift = shift,
            originalTimestamp = baseInput.timestamp,
            relativeTime = baseInput.relativeTime,
            processed = false,
        }
        
        table.insert(CBF.inputQueues.temporal, temporal)
        CBF.queueSizes.temporal = CBF.queueSizes.temporal + 1
    end
end

local function learnPattern(timestamp)
    if not CBF.predictor.enabled then return end
    
    table.insert(CBF.history.inputs, timestamp)
    CBF.history.size = CBF.history.size + 1
    
    if CBF.history.size > CBF.history.maxSize then
        table.remove(CBF.history.inputs, 1)
        CBF.history.size = CBF.history.size - 1
    end
    
    if CBF.history.size >= 2 then
        local interval = timestamp - CBF.history.inputs[CBF.history.size - 1]
        table.insert(CBF.history.intervals, interval)
        
        if #CBF.history.intervals > 1000 then
            table.remove(CBF.history.intervals, 1)
        end
        
        local sum = 0
        for _, iv in ipairs(CBF.history.intervals) do
            sum = sum + iv
        end
        CBF.predictor.averageInterval = sum / #CBF.history.intervals
        
        CBF.predictor.confidence = math.min(1.0, #CBF.history.intervals / 100)
    end
end

local function predictNextInput()
    if not CBF.predictor.enabled or CBF.predictor.confidence < 0.3 then return nil end
    
    local lastTime = CBF.history.inputs[CBF.history.size]
    if not lastTime then return nil end
    
    local interval = CBF.predictor.averageInterval
    if interval <= 0 or interval > 5e6 then return nil end
    
    local predicted = lastTime + interval
    local currentTime = getMicroTime()
    
    if predicted > currentTime and (predicted - currentTime) < 500000 then
        return predicted
    end
    
    return nil
end

local function queuePredictiveInput(predictedTime)
    if CBF.queueSizes.predictive >= CBF.maxQueueSize then return end
    
    local input = {
        type = "mouse1_predicted",
        timestamp = predictedTime,
        confidence = CBF.predictor.confidence,
        predicted = true,
        relativeTime = (os.clock() - (CBF.frameSync.lastFrameTime or os.clock())),
        processed = false,
    }
    
    table.insert(CBF.inputQueues.predictive, input)
    CBF.queueSizes.predictive = CBF.queueSizes.predictive + 1
end

local function interpolateInput(input1, input2, alpha)
    if not CBF.interpolator.enabled then return nil end
    
    local timestamp = input1.timestamp + (input2.timestamp - input1.timestamp) * alpha
    
    local interpolated = {
        type = "mouse1_interpolated",
        timestamp = timestamp,
        alpha = alpha,
        source1 = input1.timestamp,
        source2 = input2.timestamp,
        relativeTime = (os.clock() - (CBF.frameSync.lastFrameTime or os.clock())),
        processed = false,
    }
    
    if CBF.queueSizes.interpolated < CBF.maxQueueSize then
        table.insert(CBF.inputQueues.interpolated, interpolated)
        CBF.queueSizes.interpolated = CBF.queueSizes.interpolated + 1
    end
end

local function extrapolateInput(recentInputs)
    if not CBF.extrapolator.enabled or #recentInputs < 3 then return nil end
    
    local dt1 = recentInputs[2].timestamp - recentInputs[1].timestamp
    local dt2 = recentInputs[3].timestamp - recentInputs[2].timestamp
    
    local velocity = (dt1 + dt2) / 2
    local acceleration = dt2 - dt1
    
    local extrapolatedTime = recentInputs[3].timestamp + velocity + (acceleration * 0.5)
    
    local extrapolated = {
        type = "mouse1_extrapolated",
        timestamp = extrapolatedTime,
        velocity = velocity,
        acceleration = acceleration,
        relativeTime = (os.clock() - (CBF.frameSync.lastFrameTime or os.clock())),
        processed = false,
    }
    
    if CBF.queueSizes.extrapolated < CBF.maxQueueSize then
        table.insert(CBF.inputQueues.extrapolated, extrapolated)
        CBF.queueSizes.extrapolated = CBF.queueSizes.extrapolated + 1
    end
end

local function captureInput(inputType, sourcePriority)
    if not CBF.enabled then return end
    
    local timestamp = getMicroTime()
    
    CBF.stats.totalInputs = CBF.stats.totalInputs + 1
    
    learnPattern(timestamp)
    
    queueToMultipleQueues(inputType, timestamp, sourcePriority)
    
    if CBF.instantMode then
        injectPhysicsStep(timestamp, inputType)
    end
    
    queueQuantumInput(inputType, timestamp)
    
    local baseInput = {
        type = inputType,
        timestamp = timestamp,
        relativeTime = (os.clock() - (CBF.frameSync.lastFrameTime or os.clock()))
    }
    
    queueEchoInputs(baseInput)
    
    if CBF.temporal.enabled then
        queueTemporalInputs(baseInput)
    end
    
    if CBF.chaos.enabled then
        for chaos_iteration = 1, math.floor(CBF.chaos.intensity * 10) do
            local jitterTime = timestamp + (math.random() - 0.5) * CBF.chaos.jitter * 1e6
            queueToMultipleQueues(inputType .. "_chaos", jitterTime, sourcePriority * CBF.chaos.boost)
        end
    end
end

local function processQueue(queue, queueName, stepTime)
    local processed = 0
    local processingStart = getMicroTime()
    
    for i = #queue, 1, -1 do
        local input = queue[i]
        
        if not input.processed and input.relativeTime <= stepTime then
            input.processed = true
            
            if CBF.callbacks.onInput then
                pcall(function()
                    CBF.callbacks.onInput(input.type, input.timestamp, queueName)
                end)
            end
            
            local latency = getMicroTime() - input.timestamp
            
            CBF.stats.avgLatency = (CBF.stats.avgLatency * CBF.stats.processedInputs + latency) / (CBF.stats.processedInputs + 1)
            CBF.stats.minLatency = math.min(CBF.stats.minLatency, latency)
            CBF.stats.maxLatency = math.max(CBF.stats.maxLatency, latency)
            
            if latency < 0.001 then
                CBF.stats.subMicrosecondInputs = CBF.stats.subMicrosecondInputs + 1
            end
            
            if latency < 1 then
                CBF.stats.perfectInputs = CBF.stats.perfectInputs + 1
            end
            
            if queueName == "instant" then
                CBF.stats.instantInputs = CBF.stats.instantInputs + 1
            end
            
            CBF.stats.processedInputs = CBF.stats.processedInputs + 1
            processed = processed + 1
            
            table.remove(queue, i)
        end
    end
    
    local processingTime = getMicroTime() - processingStart
    CBF.stats.totalProcessingTime = CBF.stats.totalProcessingTime + processingTime
    CBF.stats.avgProcessingTime = CBF.stats.totalProcessingTime / math.max(1, CBF.stats.processedInputs)
    CBF.stats.peakProcessingTime = math.max(CBF.stats.peakProcessingTime, processingTime)
    
    return processed
end

local function processInjectedSteps(stepTime)
    for i = #CBF.physicsStepInjection.injectedSteps, 1, -1 do
        local step = CBF.physicsStepInjection.injectedSteps[i]
        
        if not step.processed and step.timestamp <= (getMicroTime()) then
            step.processed = true
            
            if CBF.callbacks.onInput then
                pcall(function()
                    CBF.callbacks.onInput(step.inputType, step.timestamp, "physics_injected")
                end)
            end
            
            table.remove(CBF.physicsStepInjection.injectedSteps, i)
            CBF.physicsStepInjection.stepCount = CBF.physicsStepInjection.stepCount - 1
        end
    end
end

UIS.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        CBF.inputStates.mouse1.current = true
        CBF.inputStates.mouse1.pressTime = getMicroTime()
        captureInput("mouse1_uis_began", 1000)
    elseif input.UserInputType == Enum.UserInputType.Touch then
        captureInput("mouse1_touch", 1000)
    end
end)

UIS.InputEnded:Connect(function(input, gameProcessed)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        CBF.inputStates.mouse1.current = false
        CBF.inputStates.mouse1.releaseTime = getMicroTime()
        CBF.inputStates.mouse1.holdDuration = CBF.inputStates.mouse1.releaseTime - CBF.inputStates.mouse1.pressTime
        captureInput("mouse1_uis_ended", 900)
    end
end)

UIS.InputChanged:Connect(function(input, gameProcessed)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        captureInput("mouse1_uis_changed", 800)
    end
end)

mouse.Button1Down:Connect(function()
    captureInput("mouse1_legacy_down", 950)
end)

mouse.Button1Up:Connect(function()
    captureInput("mouse1_legacy_up", 900)
end)

ContextActionService:BindAction("CBF_Mouse1", function(actionName, inputState, inputObject)
    if inputState == Enum.UserInputState.Begin then
        captureInput("mouse1_context_begin", 900)
    elseif inputState == Enum.UserInputState.End then
        captureInput("mouse1_context_end", 850)
    elseif inputState == Enum.UserInputState.Change then
        captureInput("mouse1_context_change", 800)
    end
end, false, Enum.UserInputType.MouseButton1, Enum.UserInputType.Touch)

for pollLevel = 1, 3 do
    task.spawn(function()
        local rate = CBF.pollingRates.primary / (2 ^ (pollLevel - 1))
        
        while true do
            if CBF.enabled then
                local mouseState = UIS:IsMouseButtonPressed(Enum.UserInputType.MouseButton1)
                if mouseState and not CBF.inputStates.mouse1.previous then
                    captureInput("mouse1_poll_" .. tostring(math.floor(rate)), 700 - (pollLevel * 50))
                end
                CBF.inputStates.mouse1.previous = mouseState
            end
            
            task.wait(1 / rate)
        end
    end)
end

task.spawn(function()
    while true do
        task.wait(1 / 60)
        
        if CBF.enabled and CBF.predictor.enabled then
            local predicted = predictNextInput()
            if predicted then
                queuePredictiveInput(predicted)
            end
        end
    end
end)

task.spawn(function()
    while true do
        RS.RenderStepped:Wait()
        
        if not CBF.enabled then continue end
        
        CBF.frameSync.lastFrameTime = os.clock()
        CBF.frameSync.frameNumber = CBF.frameSync.frameNumber + 1
        CBF.frameSync.subFrame = 0
        
        if CBF.callbacks.onFrameSync then
            pcall(function()
                CBF.callbacks.onFrameSync(CBF.frameSync.frameNumber)
            end)
        end
    end
end)

RS.RenderStepped:Connect(function(deltaTime)
    if not CBF.enabled then return end
    
    local steps = math.max(1, math.floor(deltaTime * CBF.currentTPS))
    
    for step = 1, steps do
        CBF.frameSync.subFrame = step
        
        local stepTime = (step / steps) * deltaTime
        
        for microStep = 1, CBF.subStepsPerStep do
            CBF.frameSync.microFrame = microStep
            
            local microTime = stepTime + ((microStep / CBF.subStepsPerStep) * (deltaTime / steps))
            
            processQueue(CBF.inputQueues.instant, "instant", microTime)
            processQueue(CBF.inputQueues.primary, "primary", microTime)
            processQueue(CBF.inputQueues.quantum, "quantum", microTime)
            processQueue(CBF.inputQueues.predictive, "predictive", microTime)
            processQueue(CBF.inputQueues.echo, "echo", microTime)
            
            processInjectedSteps(microTime)
        end
    end
end)

RS.Heartbeat:Connect(function(deltaTime)
    if not CBF.enabled then return end
    
    for queueName, queue in pairs(CBF.inputQueues) do
        CBF.queueSizes[queueName] = #queue
    end
    
    local currentTime = getMicroTime()
    local cutoff = currentTime - 10000000
    
    for queueName, queue in pairs(CBF.inputQueues) do
        for i = #queue, 1, -1 do
            if queue[i].timestamp < cutoff then
                table.remove(queue, i)
            end
        end
    end
end)

task.spawn(function()
    while true do
        task.wait(30)
        
        if CBF.stats.totalInputs > 0 then
            local processRate = (CBF.stats.processedInputs / CBF.stats.totalInputs) * 100
            local dropRate = (CBF.stats.droppedInputs / CBF.stats.totalInputs) * 100
            
            local totalQueued = 0
            for _, size in pairs(CBF.queueSizes) do
                totalQueued = totalQueued + size
            end
            
            warn(string.format(
                "[GeoForge v10.00] Total=%d | Processed=%d (%.1f%%) | Queued=%d | Latency: Avg=%.3fμs Min=%.3fμs Max=%.3fμs | Perfect=%d | SubMicro=%d | Instant=%d | Injected=%d | TPS=%d",
                CBF.stats.totalInputs,
                CBF.stats.processedInputs,
                processRate,
                totalQueued,
                CBF.stats.avgLatency,
                CBF.stats.minLatency,
                CBF.stats.maxLatency,
                CBF.stats.perfectInputs,
                CBF.stats.subMicrosecondInputs,
                CBF.stats.instantInputs,
                CBF.stats.injectedSteps,
                CBF.currentTPS
            ))
        end
    end
end)

task.spawn(function()
    task.wait(3)
    
    local flagFile = "GeoForge_Settings.json"
    local popupViewed = false
    
    if isfile and readfile then
        if isfile(flagFile) then
            local success, data = pcall(function()
                return HttpService:JSONDecode(readfile(flagFile))
            end)
            if success and data and data.PopupViewed == true then
                popupViewed = true
            end
        end
    end
    
    if popupViewed then return end
    
    pcall(function()
        local uiM = require(lp.PlayerScripts.Client.UI.UIManager)
        local ui = uiM.new(lp.PlayerGui.MainUI)
        ui:PushModal("NotificationModal")
        
        local mainUI = lp.PlayerGui:WaitForChild("MainUI")
        local modals = mainUI:WaitForChild("Modals")
        local n = modals:WaitForChild("NotificationModal")
        
        local title = n:WaitForChild("Title")
        local msg = n:WaitForChild("Message")
        local ok = n:WaitForChild("Ok")
        
        title.Text = "GeoForge v10.00 - CBF System Active"
        msg.Text = "Click Between Frames system loaded.\n\n" ..
                   "Features:\n" ..
                   "- 1000 Hz adaptive polling (3 levels)\n" ..
                   "- 480 TPS with 4 sub-steps (1920 steps/sec)\n" ..
                   "- Microsecond precision timing\n" ..
                   "- Physics step injection\n" ..
                   "- Zero input latency mode\n" ..
                   "- 5 redundant input queues\n" ..
                   "- Predictive AI system\n" ..
                   "- 3x echo redundancy\n" ..
                   "- Quantum state processing\n\n" ..
                   "Inputs register at exact microsecond,\n" ..
                   "not rounded to frames.\n\n" ..
                   "Based on CBF mod by Syzzi."
        
        ok.MouseButton1Click:Connect(function()
            if writefile then
                writefile(flagFile, HttpService:JSONEncode({PopupViewed = true}))
            end
            ui:PopModal()
        end)
    end)
end)

_G.GeoForge = {
    Version = "v10.00",
    
    CBF = {
        GetStats = function()
            return {
                totalInputs = CBF.stats.totalInputs,
                processedInputs = CBF.stats.processedInputs,
                droppedInputs = CBF.stats.droppedInputs,
                injectedSteps = CBF.stats.injectedSteps,
                
                latency = {
                    avg = CBF.stats.avgLatency,
                    min = CBF.stats.minLatency,
                    max = CBF.stats.maxLatency,
                },
                
                precision = {
                    perfect = CBF.stats.perfectInputs,
                    subMicrosecond = CBF.stats.subMicrosecondInputs,
                    instant = CBF.stats.instantInputs,
                },
                
                processing = {
                    avg = CBF.stats.avgProcessingTime,
                    peak = CBF.stats.peakProcessingTime,
                },
                
                queues = CBF.queueSizes,
                
                system = {
                    tps = CBF.currentTPS,
                    pollingRate = CBF.pollingRates.primary,
                    subSteps = CBF.subStepsPerStep,
                },
                
                predictor = {
                    confidence = CBF.predictor.confidence,
                    averageInterval = CBF.predictor.averageInterval,
                },
            }
        end,
        
        SetTPS = function(tps)
            CBF.currentTPS = math.clamp(tps, 1000, CBF.maxTPS)
            CBF.stepDelta = 1 / CBF.currentTPS
        end,
        
        SetPollingRate = function(rate)
            CBF.pollingRates.primary = math.clamp(rate, 1000, 1000000)
        end,
        
        SetInstantMode = function(enabled)
            CBF.instantMode = enabled
        end,
        
        SetPhysicsInjection = function(enabled)
            CBF.physicsInjection = enabled
        end,
        
        SetZeroLatency = function(enabled)
            CBF.zeroLatency = enabled
        end,
        
        RegisterCallback = function(callback)
            CBF.callbacks.onInput = callback
        end,
        
        RegisterPhysicsCallback = function(callback)
            CBF.callbacks.onPhysicsStep = callback
        end,
        
        ResetStats = function()
            CBF.stats = {
                totalInputs = 0,
                processedInputs = 0,
                injectedSteps = 0,
                droppedInputs = 0,
                avgLatency = 0,
                minLatency = math.huge,
                maxLatency = 0,
                perfectInputs = 0,
                subMicrosecondInputs = 0,
                instantInputs = 0,
                totalProcessingTime = 0,
                avgProcessingTime = 0,
                peakProcessingTime = 0,
            }
        end,
    },
    
    Performance = {
        GetFPS = function() return math.floor(PerfMonitor.currentFPS) end,
        GetRenderDistance = function() return math.floor(currentRenderDist) end,
        SetRenderDistance = function(dist)
            currentRenderDist = math.clamp(dist, CFG.RENDER_DIST.POTATO, CFG.RENDER_DIST.ULTRA)
        end,
    },
}

warn("[GeoForge v10.00] Click Between Frames system loaded")
warn("[CBF] Polling: 1kHz | TPS: " .. CBF.currentTPS .. " | Sub-steps: " .. CBF.subStepsPerStep)
warn("[CBF] Physics injection: " .. tostring(CBF.physicsInjection))
warn("[CBF] Zero latency mode: " .. tostring(CBF.zeroLatency))
warn("[CBF] Based on Click Between Frames mod by Syzzi")
